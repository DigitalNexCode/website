/*
# Initial Schema Setup
This migration sets up the core tables for the DigitalNexCode website, including user profiles, blog posts, and payments. It also establishes Row Level Security (RLS) to ensure data privacy and security.

## Query Description:
This script creates new tables and sets up security policies. It is designed to run on a new or empty database and is not intended to alter existing user data. It is safe to run as it only adds new structures.

## Metadata:
- Schema-Category: "Structural"
- Impact-Level: "Low"
- Requires-Backup: false
- Reversible: true (by dropping the created tables and policies)

## Structure Details:
- Tables created: `profiles`, `posts`, `payments`
- Policies created: RLS policies for all three tables.
- Triggers created: `on_auth_user_created` to automatically create a user profile.

## Security Implications:
- RLS Status: Enabled for all new tables.
- Policy Changes: Yes, new policies are created.
- Auth Requirements: Policies are tied to `auth.uid()`, restricting access to authenticated users.

## Performance Impact:
- Indexes: Primary keys and foreign keys are indexed by default.
- Triggers: One trigger is added to handle new user profile creation.
- Estimated Impact: Low performance impact, standard for new table creation.
*/

-- 1. PROFILES TABLE
-- Stores public user data.
CREATE TABLE public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'user'
);

-- RLS policy for profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Trigger to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 2. POSTS TABLE
-- Stores blog posts.
CREATE TABLE public.posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  excerpt TEXT,
  image_url TEXT,
  author_id UUID NOT NULL REFERENCES public.profiles(id),
  category TEXT,
  tags TEXT[]
);

-- RLS policy for posts
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Posts are viewable by everyone." ON public.posts FOR SELECT USING (true);
CREATE POLICY "Admin users can insert posts." ON public.posts FOR INSERT WITH CHECK (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'
);
CREATE POLICY "Admin users can update posts." ON public.posts FOR UPDATE USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'
);
CREATE POLICY "Admin users can delete posts." ON public.posts FOR DELETE USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin'
);


-- 3. PAYMENTS TABLE
-- Stores payment records from Yoco.
CREATE TABLE public.payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  amount_in_cents INT NOT NULL,
  plan_name TEXT NOT NULL,
  payment_plan TEXT,
  yoco_charge_id TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'completed'
);

-- RLS policy for payments
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own payments." ON public.payments FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own payments." ON public.payments FOR INSERT WITH CHECK (auth.uid() = user_id);
